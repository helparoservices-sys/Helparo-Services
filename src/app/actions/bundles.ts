'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { requireAuth } from '@/lib/auth-middleware'
import { handleServerActionError } from '@/lib/errors'
import { sanitizeText } from '@/lib/sanitize'
import { rateLimit, RATE_LIMITS } from '@/lib/rate-limit'
import { UserRole } from '@/lib/constants'
import { logger } from '@/lib/logger'

/**
 * Server Actions for Bundles & Campaigns (Migration 023)
 * Tables: service_bundles, bundle_services, bundle_purchases, seasonal_campaigns, campaign_applicable_services, campaign_redemptions
 */

// ============================================
// SERVICE BUNDLES
// ============================================

export async function createServiceBundle(formData: FormData) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('create-service-bundle', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const name = sanitizeText(formData.get('name') as string)
    const description = sanitizeText(formData.get('description') as string)
    const bundleType = sanitizeText(formData.get('bundle_type') as string) || 'combo'
    const iconUrl = sanitizeText(formData.get('icon_url') as string)
    const bannerUrl = sanitizeText(formData.get('banner_url') as string)
    const termsConditions = sanitizeText(formData.get('terms_conditions') as string)
    const totalOriginalPrice = parseFloat(formData.get('total_original_price') as string)
    const bundlePrice = parseFloat(formData.get('bundle_price') as string)
    const validityDays = parseInt(formData.get('validity_days') as string)
    const maxRedemptions = parseInt(formData.get('max_redemptions') as string)

    if (!name || !description || isNaN(totalOriginalPrice) || isNaN(bundlePrice)) {
      return { error: 'Invalid input data' }
    }

    if (!['combo', 'package', 'subscription', 'seasonal'].includes(bundleType)) {
      return { error: 'Invalid bundle type' }
    }

    const supabase = await createClient()

    // discount_percentage is auto-generated by database
    const { data: bundle, error } = await supabase
      .from('service_bundles')
      .insert({
        name,
        description,
        bundle_type: bundleType,
        icon_url: iconUrl || null,
        banner_url: bannerUrl || null,
        terms_conditions: termsConditions || null,
        total_original_price: totalOriginalPrice,
        bundle_price: bundlePrice,
        validity_days: validityDays || 30,
        max_redemptions: maxRedemptions || 1,
        is_active: true
      })
      .select()
      .single()

    if (error) throw error

    revalidatePath('/admin/bundles')
    revalidatePath('/customer/bundles')
    logger.info('Service bundle created', { adminId: user.id, bundleId: bundle.id, name })
    return { success: true, bundle }
  } catch (error: any) {
    logger.error('Create service bundle error:', error)
    return handleServerActionError(error)
  }
}

export async function updateServiceBundle(bundleId: string, formData: FormData) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('update-service-bundle', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const name = sanitizeText(formData.get('name') as string)
    const description = sanitizeText(formData.get('description') as string)
    const bundleType = sanitizeText(formData.get('bundle_type') as string)
    const iconUrl = sanitizeText(formData.get('icon_url') as string)
    const bannerUrl = sanitizeText(formData.get('banner_url') as string)
    const termsConditions = sanitizeText(formData.get('terms_conditions') as string)
    const totalOriginalPrice = parseFloat(formData.get('total_original_price') as string)
    const bundlePrice = parseFloat(formData.get('bundle_price') as string)
    const validityDays = parseInt(formData.get('validity_days') as string)
    const maxRedemptions = parseInt(formData.get('max_redemptions') as string)

    if (!name || !description || isNaN(totalOriginalPrice) || isNaN(bundlePrice)) {
      return { error: 'Invalid input data' }
    }

    if (bundleType && !['combo', 'package', 'subscription', 'seasonal'].includes(bundleType)) {
      return { error: 'Invalid bundle type' }
    }

    const supabase = await createClient()

    const updates: any = {
      name,
      description,
      bundle_type: bundleType || 'combo',
      total_original_price: totalOriginalPrice,
      bundle_price: bundlePrice,
      validity_days: validityDays || 30,
      max_redemptions: maxRedemptions || 1
    }

    if (iconUrl) updates.icon_url = iconUrl
    if (bannerUrl) updates.banner_url = bannerUrl
    if (termsConditions) updates.terms_conditions = termsConditions

    const { data: bundle, error } = await supabase
      .from('service_bundles')
      .update(updates)
      .eq('id', bundleId)
      .select()
      .single()

    if (error) throw error

    revalidatePath('/admin/bundles')
    revalidatePath('/customer/bundles')
    logger.info('Service bundle updated', { adminId: user.id, bundleId, name })
    return { success: true, bundle }
  } catch (error: any) {
    logger.error('Update service bundle error:', error)
    return handleServerActionError(error)
  }
}

export async function deleteServiceBundle(bundleId: string) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('delete-service-bundle', user.id, RATE_LIMITS.ADMIN_APPROVE)
    
    const supabase = await createClient()

    // Check if bundle has active purchases
    const { data: purchases, error: checkError } = await supabase
      .from('bundle_purchases')
      .select('id')
      .eq('bundle_id', bundleId)
      .gte('valid_until', new Date().toISOString())
      .limit(1)

    if (checkError) throw checkError

    if (purchases && purchases.length > 0) {
      return { error: 'Cannot delete bundle with active customer purchases. Deactivate instead.' }
    }

    // Delete bundle (cascade will delete bundle_services)
    const { error } = await supabase
      .from('service_bundles')
      .delete()
      .eq('id', bundleId)

    if (error) throw error

    revalidatePath('/admin/bundles')
    revalidatePath('/customer/bundles')
    logger.info('Service bundle deleted', { adminId: user.id, bundleId })
    return { success: true }
  } catch (error: any) {
    logger.error('Delete service bundle error:', error)
    return handleServerActionError(error)
  }
}

export async function addServiceToBundle(bundleId: string, categoryId: string, quantity: number, pricePerService: number) {
  const supabase = await createClient()

  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('admin-action', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const supabase = await createClient()

    const { data, error } = await supabase
      .from('bundle_services')
      .insert({
        bundle_id: bundleId,
        category_id: categoryId,
        quantity,
        price_per_service: pricePerService
      })
      .select()
      .single()

    if (error) throw error

    revalidatePath('/admin/bundles')
    return { success: true, bundleService: data }
  } catch (error: any) {
    logger.error('Add service to bundle error:', error)
    return handleServerActionError(error)
  }
}

export async function getActiveServiceBundles() {
  try {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('service_bundles')
      .select(`
        *,
        services:bundle_services(
          quantity,
          individual_price,
          category:service_categories(
            id,
            name,
            icon
          )
        )
      `)
      .order('created_at', { ascending: false })

    if (error) throw error

    return { success: true, bundles: data || [] }
  } catch (error: any) {
    logger.error('Get active service bundles error:', error)
    return handleServerActionError(error)
  }
}

export async function purchaseBundle(bundleId: string) {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { error: 'Unauthorized' }

    // Get bundle details
    const { data: bundle } = await supabase
      .from('service_bundles')
      .select('*, services:bundle_services(*)')
      .eq('id', bundleId)
      .single()

    if (!bundle || !bundle.is_active) {
      return { error: 'Bundle not available' }
    }

    // Check wallet balance
    const { data: wallet } = await supabase
      .from('wallet_accounts')
      .select('balance')
      .eq('user_id', user.id)
      .single()

    if (!wallet || wallet.balance < bundle.bundle_price) {
      return { error: 'Insufficient wallet balance' }
    }

    // Calculate expiry date
    const expiryDate = new Date()
    expiryDate.setDate(expiryDate.getDate() + bundle.validity_days)

    // Create bundle purchase
    const { data: purchase, error: purchaseError } = await supabase
      .from('bundle_purchases')
      .insert({
        bundle_id: bundleId,
        customer_id: user.id,
        purchase_price: bundle.bundle_price,
        remaining_redemptions: bundle.max_redemptions,
        expiry_date: expiryDate.toISOString()
      })
      .select()
      .single()

    if (purchaseError) throw purchaseError

    // Deduct from wallet
    const { error: walletError } = await supabase
      .from('wallet_accounts')
      .update({ balance: wallet.balance - bundle.bundle_price })
      .eq('user_id', user.id)

    if (walletError) throw walletError

    // Create transaction record
    await supabase
      .from('payment_transactions')
      .insert({
        user_id: user.id,
        amount: bundle.bundle_price,
        transaction_type: 'bundle_purchase',
        status: 'completed',
        description: `Purchased ${bundle.name}`
      })

    revalidatePath('/customer/bundles')
    revalidatePath('/customer/wallet')
    return { success: true, purchase }
  } catch (error: any) {
    logger.error('Purchase bundle error:', error)
    return handleServerActionError(error)
  }
}

export async function getMyBundles() {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { error: 'Unauthorized' }

    const { data, error } = await supabase
      .from('bundle_purchases')
      .select(`
        *,
        bundle:service_bundles(
          name,
          description,
          image_url,
          services:bundle_services(
            quantity,
            category:service_categories(name, icon)
          )
        )
      `)
      .eq('customer_id', user.id)
      .gte('expiry_date', new Date().toISOString())
      .gt('remaining_redemptions', 0)
      .order('created_at', { ascending: false })

    if (error) throw error

    return { success: true, bundles: data }
  } catch (error: any) {
    logger.error('Get my bundles error:', error)
    return handleServerActionError(error)
  }
}

export async function redeemBundleService(purchaseId: string, categoryId: string) {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { error: 'Unauthorized' }

    // Get purchase details
    const { data: purchase } = await supabase
      .from('bundle_purchases')
      .select('*, bundle:service_bundles(services:bundle_services(*))')
      .eq('id', purchaseId)
      .eq('customer_id', user.id)
      .single()

    if (!purchase) {
      return { error: 'Bundle purchase not found' }
    }

    if (purchase.remaining_redemptions <= 0) {
      return { error: 'No redemptions remaining' }
    }

    if (new Date(purchase.expiry_date) < new Date()) {
      return { error: 'Bundle has expired' }
    }

    // Decrease redemption count
    const { error: updateError } = await supabase
      .from('bundle_purchases')
      .update({ remaining_redemptions: purchase.remaining_redemptions - 1 })
      .eq('id', purchaseId)

    if (updateError) throw updateError

    revalidatePath('/customer/bundles')
    return { success: true }
  } catch (error: any) {
    logger.error('Redeem bundle service error:', error)
    return handleServerActionError(error)
  }
}

// ============================================
// SEASONAL CAMPAIGNS
// ============================================

// New aligned create function (keeps compatibility by exporting old name wrapper)
export async function createCampaign(formData: FormData) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('create-campaign', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const supabase = await createClient()

    const name = sanitizeText(formData.get('name') as string)
    const description = sanitizeText(formData.get('description') as string)
    const bannerUrl = sanitizeText(formData.get('banner_url') as string)
    const campaignType = sanitizeText(formData.get('campaign_type') as string)
    const discountType = sanitizeText(formData.get('discount_type') as string)
    const discountValue = parseFloat(formData.get('discount_value') as string)
    const minOrderAmountRaw = formData.get('min_order_amount') as string
    const maxDiscountAmountRaw = formData.get('max_discount_amount') as string
    const applicableTo = sanitizeText(formData.get('applicable_to') as string)
    const targetUserSegment = sanitizeText(formData.get('target_user_segment') as string)
    const startDate = formData.get('start_date') as string
    const endDate = formData.get('end_date') as string
    const maxRedemptionsPerUserRaw = formData.get('max_redemptions_per_user') as string

    if (!name || !campaignType || !discountType || isNaN(discountValue) || !startDate || !endDate) {
      return { error: 'Missing required fields' }
    }

    const minOrderAmount = minOrderAmountRaw ? parseFloat(minOrderAmountRaw) : null
    const maxDiscountAmount = maxDiscountAmountRaw ? parseFloat(maxDiscountAmountRaw) : null
    const maxRedemptionsPerUser = maxRedemptionsPerUserRaw ? parseInt(maxRedemptionsPerUserRaw) : null

    const { data: campaign, error } = await supabase
      .from('seasonal_campaigns')
      .insert({
        name,
        description,
        banner_url: bannerUrl || null,
        campaign_type: campaignType,
        discount_type: discountType,
        discount_value: discountValue,
        min_order_amount: minOrderAmount,
        max_discount_amount: maxDiscountAmount,
        applicable_to: applicableTo || 'all_services',
        target_user_segment: targetUserSegment || 'all',
        start_date: startDate,
        end_date: endDate,
        max_redemptions_per_user: maxRedemptionsPerUser,
        is_active: true
      })
      .select()
      .single()

    if (error) throw error

    // Handle category associations if provided and scope requires
    const categoryIds = formData.getAll('category_ids[]') as string[]
    if (campaign && applicableTo === 'specific_categories' && categoryIds.length) {
      const rows = categoryIds.map(id => ({ campaign_id: campaign.id, category_id: id }))
      const { error: catError } = await supabase.from('campaign_applicable_services').insert(rows)
      if (catError) throw catError
    }

    revalidatePath('/admin/campaigns')
    revalidatePath('/customer/offers')
    logger.info('Campaign created', { adminId: user.id, campaignId: campaign.id })
    return { success: true, campaign }
  } catch (error: any) {
    logger.error('Create campaign error:', error)
    return handleServerActionError(error)
  }
}

// Backwards compatibility wrapper (old name)
export async function createSeasonalCampaign(formData: FormData) {
  return createCampaign(formData)
}

export async function updateCampaign(campaignId: string, formData: FormData) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('update-campaign', user.id, RATE_LIMITS.ADMIN_APPROVE)
    const supabase = await createClient()

    const updates: any = {}
    const directFields = [
      'name','description','campaign_type','discount_type','discount_value','min_order_amount','max_discount_amount','applicable_to','target_user_segment','start_date','end_date','max_redemptions_per_user','banner_url'
    ]
    directFields.forEach(f => {
      const val = formData.get(f)
      if (val !== null && val !== '') {
        updates[f] = f.includes('amount') || f === 'discount_value' ? parseFloat(val as string) : sanitizeText(val as string)
      }
    })

    if (Object.keys(updates).length === 0) return { error: 'No updates provided' }

    const { data, error } = await supabase
      .from('seasonal_campaigns')
      .update(updates)
      .eq('id', campaignId)
      .select()
      .single()

    if (error) throw error

    // Replace category links if provided and scope requires
    const categoryIds = formData.getAll('category_ids[]') as string[]
    if (updates.applicable_to === 'specific_categories') {
      // remove existing
      const { error: delError } = await supabase.from('campaign_applicable_services').delete().eq('campaign_id', campaignId)
      if (delError) throw delError
      if (categoryIds.length) {
        const rows = categoryIds.map(id => ({ campaign_id: campaignId, category_id: id }))
        const { error: insError } = await supabase.from('campaign_applicable_services').insert(rows)
        if (insError) throw insError
      }
    }

    revalidatePath('/admin/campaigns')
    revalidatePath('/customer/offers')
    logger.info('Campaign updated', { adminId: user.id, campaignId })
    return { success: true, campaign: data }
  } catch (error: any) {
    logger.error('Update campaign error:', error)
    return handleServerActionError(error)
  }
}

export async function deleteCampaign(campaignId: string) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('delete-campaign', user.id, RATE_LIMITS.ADMIN_APPROVE)
    const supabase = await createClient()

    const { error } = await supabase
      .from('seasonal_campaigns')
      .delete()
      .eq('id', campaignId)

    if (error) throw error
    revalidatePath('/admin/campaigns')
    revalidatePath('/customer/offers')
    logger.info('Campaign deleted', { adminId: user.id, campaignId })
    return { success: true }
  } catch (error: any) {
    logger.error('Delete campaign error:', error)
    return handleServerActionError(error)
  }
}

export async function getAllCampaigns() {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('list-campaigns', user.id, RATE_LIMITS.API_RELAXED)
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('seasonal_campaigns')
      .select('*, categories:campaign_applicable_services(category_id)')
      .order('created_at', { ascending: false })

    if (error) throw error
    return { success: true, campaigns: data }
  } catch (error: any) {
    logger.error('Get all campaigns error:', error)
    return handleServerActionError(error)
  }
}

export async function addServiceToCampaign(campaignId: string, categoryId: string) {
  const supabase = await createClient()

  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('admin-action', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const supabase = await createClient()

    const { data, error } = await supabase
      .from('campaign_applicable_services')
      .insert({
        campaign_id: campaignId,
        category_id: categoryId
      })
      .select()
      .single()

    if (error) throw error

    revalidatePath('/admin/campaigns')
    return { success: true, campaignService: data }
  } catch (error: any) {
    logger.error('Add service to campaign error:', error)
    return handleServerActionError(error)
  }
}

export async function getActiveCampaigns() {
  try {
    const supabase = await createClient()
    const now = new Date().toISOString()
    const { data, error } = await supabase
      .from('seasonal_campaigns')
      .select('*')
      .eq('is_active', true)
      .lte('start_date', now)
      .gte('end_date', now)
      .order('created_at', { ascending: false })
    if (error) throw error
    return { success: true, campaigns: data }
  } catch (error: any) {
    logger.error('Get active campaigns error:', error)
    return handleServerActionError(error)
  }
}

export async function applyCampaignToOrder(campaignId: string, serviceRequestId: string, originalAmount: number) {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { error: 'Unauthorized' }

    // Get campaign details
    const { data: campaign } = await supabase
      .from('seasonal_campaigns')
      .select('*')
      .eq('id', campaignId)
      .single()

    if (!campaign || !campaign.is_active) {
      return { error: 'Campaign not available' }
    }

    // Check if campaign is valid
    const now = new Date()
    if (now < new Date(campaign.start_date) || now > new Date(campaign.end_date)) {
      return { error: 'Campaign has expired' }
    }

    // Check min order amount
    if (campaign.min_order_amount && originalAmount < campaign.min_order_amount) {
      return { error: `Minimum order amount is â‚¹${campaign.min_order_amount}` }
    }

    // Check redemption limit
    const { count: redemptionCount } = await supabase
      .from('campaign_redemptions')
      .select('*', { count: 'exact', head: true })
      .eq('campaign_id', campaignId)
      .eq('customer_id', user.id)

    if (redemptionCount && redemptionCount >= campaign.max_redemptions_per_user) {
      return { error: 'Maximum redemptions reached for this campaign' }
    }

    // Calculate discount
    let discountAmount = 0
    if (campaign.discount_type === 'percentage') {
      discountAmount = (originalAmount * campaign.discount_value) / 100
    } else if (campaign.discount_type === 'flat') {
      discountAmount = campaign.discount_value
    }
    if (campaign.max_discount_amount && discountAmount > campaign.max_discount_amount) {
      discountAmount = campaign.max_discount_amount
    }

    const finalAmount = Math.max(0, originalAmount - discountAmount)

    // Create redemption record
    const { data: redemption, error: redemptionError } = await supabase
      .from('campaign_redemptions')
      .insert({
        campaign_id: campaignId,
        customer_id: user.id,
        request_id: serviceRequestId,
        original_amount: originalAmount,
        discount_applied: discountAmount,
        final_amount: finalAmount
      })
      .select()
      .single()

    if (redemptionError) throw redemptionError

    // Update total redemptions
    const { error: updateError } = await supabase
      .from('seasonal_campaigns')
      .update({ 
        total_redemptions: (campaign.total_redemptions || 0) + 1,
        total_revenue: (campaign.total_revenue || 0) + finalAmount
      })
      .eq('id', campaignId)

    if (updateError) throw updateError

    revalidatePath('/customer/requests')
    return { success: true, redemption, finalAmount, discountAmount }
  } catch (error: any) {
    logger.error('Apply campaign to order error:', error)
    return handleServerActionError(error)
  }
}

export async function getMyCampaignRedemptions() {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return { error: 'Unauthorized' }

    const { data, error } = await supabase
      .from('campaign_redemptions')
      .select(`
        *,
        campaign:seasonal_campaigns(
          title,
          campaign_type,
          banner_url
        ),
        service_request:service_requests(
          title,
          status
        )
      `)
      .eq('customer_id', user.id)
      .order('created_at', { ascending: false })
      .limit(50)

    if (error) throw error

    return { success: true, redemptions: data }
  } catch (error: any) {
    logger.error('Get my campaign redemptions error:', error)
    return handleServerActionError(error)
  }
}

export async function toggleBundleStatus(bundleId: string, isActive: boolean) {
  const supabase = await createClient()

  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('admin-action', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const supabase = await createClient()

    const { error } = await supabase
      .from('service_bundles')
      .update({ is_active: isActive })
      .eq('id', bundleId)

    if (error) throw error

    revalidatePath('/admin/bundles')
    revalidatePath('/customer/bundles')
    return { success: true }
  } catch (error: any) {
    logger.error('Toggle bundle status error:', error)
    return handleServerActionError(error)
  }
}

/**
 * Add services to a bundle (bundle_services junction table)
 */
export async function addBundleServices(
  bundleId: string,
  services: Array<{ categoryId: string; quantity: number; individualPrice: number }>
) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('admin-action', user.id, RATE_LIMITS.ADMIN_APPROVE)

    const supabase = await createClient()

    // Delete existing services for this bundle first
    await supabase
      .from('bundle_services')
      .delete()
      .eq('bundle_id', bundleId)

    // Insert new services
    if (services.length > 0) {
      const records = services.map((service, index) => ({
        bundle_id: bundleId,
        category_id: service.categoryId,
        quantity: service.quantity || 1,
        individual_price: service.individualPrice,
        sort_order: index + 1
      }))

      const { error } = await supabase
        .from('bundle_services')
        .insert(records)

      if (error) throw error
    }

    revalidatePath('/admin/bundles')
    revalidatePath('/customer/bundles')
    logger.info('Bundle services updated', { adminId: user.id, bundleId, count: services.length })
    return { success: true }
  } catch (error: any) {
    logger.error('Add bundle services error:', error)
    return handleServerActionError(error)
  }
}

/**
 * Get services included in a bundle
 */
export async function getBundleServices(bundleId: string) {
  try {
    const supabase = await createClient()

    const { data, error } = await supabase
      .from('bundle_services')
      .select(`
        *,
        category:service_categories(
          id,
          name,
          icon
        )
      `)
      .eq('bundle_id', bundleId)
      .order('sort_order')

    if (error) throw error

    return { success: true, services: data || [] }
  } catch (error: any) {
    logger.error('Get bundle services error:', error)
    return handleServerActionError(error)
  }
}

export async function toggleCampaignStatus(campaignId: string, isActive: boolean) {
  try {
    const { user } = await requireAuth(UserRole.ADMIN)
    await rateLimit('toggle-campaign', user.id, RATE_LIMITS.ADMIN_APPROVE)
    const supabase = await createClient()
    const { error } = await supabase
      .from('seasonal_campaigns')
      .update({ is_active: isActive })
      .eq('id', campaignId)
    if (error) throw error
    revalidatePath('/admin/campaigns')
    revalidatePath('/customer/offers')
    return { success: true }
  } catch (error: any) {
    logger.error('Toggle campaign status error:', error)
    return handleServerActionError(error)
  }
}

